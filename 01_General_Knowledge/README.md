# Makefile

A Makefile is a special file used by the `make` build automation tool to manage the build process of a project. It defines a set of rules to determine how to compile and link the program. Here's a brief overview of what a Makefile is and how to use it:

### What is a Makefile?

A Makefile contains a set of rules that specify how to build and manage dependencies in a project. Each rule consists of:

- **Target**: The file to be generated (e.g., an executable or object file).
- **Dependencies**: Files that the target depends on (e.g., source files).
- **Commands**: Shell commands to generate the target from the dependencies. Commands must be preceded by a tab character.

### Basic Structure

The general syntax of a Makefile is:

```makefile
target: dependencies
    command
```

![image](https://github.com/user-attachments/assets/70d10d46-ae68-450f-8ae9-1df21a7ed8b3)

### Key Concepts

#### Variables

Variables can be defined and used to simplify the Makefile. For example, `CC` and `CFLAGS` in the example below.

Example
```makefile
# Variables
CC := gcc
CFLAGS := -Wall -g

# Targets and dependencies
all: main.o utils.o
    $(CC) $(CFLAGS) -o myprogram main.o utils.o

main.o: main.c
    $(CC) $(CFLAGS) -c main.c

utils.o: utils.c
    $(CC) $(CFLAGS) -c utils.c

# Clean up
clean:
    rm -f *.o myprogram
```

#### Phony Targets

Targets that do not represent files, such as `clean`, can be declared as phony to avoid conflicts with files of the same name.

```makefile
.PHONY: clean
```

#### Automatic Variables: Special variables that are set automatically by make. Common ones include:

- `$@`: The target name.
- `$<`: The first dependency.
- `$^`: All dependencies.

#### Running Make
To use the Makefile, simply run the make command in the terminal. By default, make will look for a file named Makefile or makefile in the current directory.

```sh
make
```


You can also specify a particular target to build:

```sh
make clean
```


# Compilation process
The compilation process is the process of converting source code written in a programming language into executable machine code that a computer can run.. The compilation process involves four key steps:
- **Preprocessing:**
  The preprocessor handles directives like `#include` and `#define`, removes comments, and expands macros. It creates an intermediate file without any `#` statements. Result of this step is file with an extention `.i`.
- **Compilation:**
  The compiler translates the preprocessed source code into assembly language. This phase involves syntax checking, semantic analysis, and optimization of the code. Result of this step is file with an extention `.s`.
- **Assembly:**
  The assembler converts the assembly code generated by the compiler into object code, which consists of machine code instructions. The object code is typically stored in an object file with an extension such as `.o` or `.obj`.
- **Linking**
  The linker combines multiple object files and includes necessary library files to create an executable file that can be run on a computer.
  
![image](https://github.com/user-attachments/assets/b4075b0c-cf7f-42e8-9054-1f10b047a621)

# Shared lib and Static lib



### Properties of Static Library and Shared Library

| **Properties**           | **Static Library**                                                                                                                                                                                   | **Shared Library**                                                                                                                         |
|--------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
| **Linking time**         | All modules in the library are copied into the executable file at compile time. When the program is loaded into memory, the OS only loads a single executable file that includes the source code and the linked library (Static linking). | The shared library is used during the linking process when both the executable file and the library file are loaded into memory at runtime. A shared library can be used by multiple programs (Dynamic linking). |
| **Size**                 | Using a static library consumes more memory than a shared library.                                                                                                                                     | Using a shared library consumes less memory because there is only one copy in memory.                                                       |
| **External File changes**| The executable file needs to be recompiled whenever there are changes in the static library.                                                                                                           | For shared libraries, there is no need to recompile the executable file.                                                                    |
| **Time**                 | Takes more time to execute.                                                                                                                                                                            | Using a shared library takes less time to execute because the library is already in memory.                                                |
